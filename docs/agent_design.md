# Jaguar Conservation Agent Design

## Overview

The Jaguar Conservation Agent is a **Graph RAG (Retrieval-Augmented Generation)** AI agent that combines **OpenAI GPT** with **GraphDB knowledge graphs** to provide intelligent responses about jaguar conservation. This agent demonstrates how to build a conversational AI that can query structured data using SPARQL and provide natural language responses.

## Graph RAG Capabilities

### Core Graph RAG Features
- **Knowledge Graph Integration**: Direct SPARQL queries against GraphDB triple store
- **LLM-Driven Query Generation**: AI automatically generates SPARQL from natural language
- **Hybrid Intelligence**: Combines structured graph data with LLM reasoning
- **Real-time Data Retrieval**: Live queries against jaguar conservation database
- **Context-Aware Responses**: Maintains conversation context across queries

### Agent Characteristics
- **Name**: JaguarConservationAgent
- **Role**: Graph RAG specialist for jaguar conservation
- **Domain**: Jaguar population, conservation, habitats, threats
- **Architecture**: Microsoft Agent Framework with OpenAI integration

### Capabilities
1. **SPARQL Query Generation**: Convert natural language to SPARQL queries
2. **Graph Data Interpretation**: Understand complex ontology structures
3. **Natural Language Responses**: Generate human-readable answers from graph data
4. **Conversation Context**: Maintain chat history and context
5. **Markdown Formatting**: Rich text responses with code blocks and formatting

## Architecture

### Simplified POC Architecture

```
┌─────────────────────────────────────────┐
│           Flask Web App                 │
│  ┌─────────────────────────────────┐    │
│  │        Chat Interface           │    │
│  │  - HTML Form POST              │    │
│  │  - Chat History Display        │    │
│  │  - Error Handling              │    │
│  └─────────────────────────────────┘    │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│        Agent Framework                  │
│  ┌─────────────────────────────────┐    │
│  │    Jaguar Conservation Agent    │    │
│  │  ┌─────────────────────────┐    │    │
│  │  │    System Prompt        │    │    │
│  │  │  - Graph RAG Context    │    │    │
│  │  │  - SPARQL Guidelines    │    │    │
│  │  │  - Response Formatting  │    │    │
│  │  └─────────────────────────┘    │    │
│  │                                 │    │
│  │  ┌─────────────────────────┐    │    │
│  │  │    OpenAI Client        │    │    │
│  │  │  - GPT-4 Integration    │    │    │
│  │  │  - Function Calling     │    │    │
│  │  │  - Thread Management    │    │    │
│  │  └─────────────────────────┘    │    │
│  │                                 │    │
│  │  ┌─────────────────────────┐    │    │
│  │  │    GraphDB Tool         │    │    │
│  │  │  - SPARQL Execution     │    │    │
│  │  │  - Query Validation     │    │    │
│  │  │  - Result Processing    │    │    │
│  │  └─────────────────────────┘    │    │
│  └─────────────────────────────────┘    │
└─────────────────┬───────────────────────┘
                  │
┌─────────────────▼───────────────────────┐
│           External Systems              │
│  ┌─────────────────┐  ┌─────────────┐  │
│  │   OpenAI API    │  │  GraphDB    │  │
│  │   - GPT-4       │  │  - RDF Store│  │
│  │   - Responses   │  │  - SPARQL   │  │
│  └─────────────────┘  └─────────────┘  │
└─────────────────────────────────────────┘
```

## Graph RAG System Prompt

The agent uses a carefully crafted system prompt optimized for Graph RAG:

### Core Instructions
1. **Graph RAG Focus**: Always use the GraphDB tool for jaguar-related queries
2. **SPARQL Generation**: Convert natural language to valid SPARQL queries
3. **Ontology Awareness**: Base queries on the provided jaguar ontology
4. **Response Formatting**: Use markdown with code blocks for SPARQL
5. **Data Attribution**: Always mention that information comes from the jaguar database

### Key Guidelines
- Form simple queries first, add complexity only if needed
- Show the SPARQL query once in each response
- Use **bold** for emphasis when appropriate
- Use bullet points or numbered lists for multiple items
- Break up long responses into paragraphs
- Be concise but comprehensive in answers

## Graph RAG Tool Integration

### GraphDB Tool - Core Graph RAG Component

The agent's primary tool for knowledge graph retrieval:

**Function Name**: `query_jaguar_database`

**Purpose**: Execute SPARQL queries against the jaguar conservation knowledge graph

**Parameters**:
- `sparql_query`: SPARQL query string generated by the LLM

**Ontology Coverage**:
- **Classes**: Jaguar, Habitat, Location, Threat, ConservationEffort, Organization
- **Properties**: hasGender, wasKilled, rescuedBy, facesThreat, hasLocation, etc.
- **Relationships**: Complex conservation data relationships

### Graph RAG Query Examples

```sparql
# Count total jaguars in database
SELECT (COUNT(?jaguar) as ?count) WHERE { 
  ?jaguar a :Jaguar . 
}

# Find jaguars by gender with labels
SELECT ?jaguar ?label ?gender WHERE { 
  ?jaguar a :Jaguar . 
  OPTIONAL { ?jaguar rdfs:label ?label . } 
  OPTIONAL { ?jaguar :hasGender ?gender . } 
}

# Find jaguars that were killed with cause of death
SELECT ?jaguar ?label ?causeOfDeath WHERE { 
  ?jaguar a :Jaguar . 
  ?jaguar :wasKilled true . 
  OPTIONAL { ?jaguar rdfs:label ?label . } 
  OPTIONAL { ?jaguar :causeOfDeath ?causeOfDeath . } 
}

# Find conservation efforts by organization
SELECT ?effort ?org ?description WHERE {
  ?effort a :ConservationEffort .
  ?effort :conductedBy ?org .
  ?effort rdfs:label ?description .
  ?org a :Organization .
}
```

## Graph RAG Processing Flow

### 1. User Query Reception
```python
# Flask route receives user message
user_message = request.form.get('message', '').strip()
```

### 2. Agent Framework Processing
```python
# Get agent and thread (singleton pattern)
agent = get_agent()
thread = get_thread()

# Run agent with conversation context
response = asyncio.run(agent.run(user_message, thread=thread, store=True))
```

### 3. Graph RAG Query Generation
- **LLM Analysis**: OpenAI GPT analyzes the user's natural language query
- **SPARQL Generation**: AI generates appropriate SPARQL query for GraphDB
- **Ontology Mapping**: Maps user intent to jaguar ontology classes/properties

### 4. Knowledge Graph Query Execution
- **Tool Call Detection**: Agent Framework detects need for GraphDB tool
- **SPARQL Execution**: `query_jaguar_database` tool executes query against GraphDB
- **Result Processing**: Raw SPARQL results are processed and formatted

### 5. Response Generation
- **LLM Interpretation**: OpenAI GPT interprets GraphDB results
- **Natural Language Response**: Generates human-readable response
- **Markdown Formatting**: Applies formatting with code blocks for SPARQL

### 6. Context Preservation
- **Thread Management**: Agent Framework maintains conversation context
- **Chat History**: Flask app stores UI display history
- **State Persistence**: Conversation state preserved across requests

## Graph RAG State Management

### Simplified POC State
```python
# Global Flask app configuration
app.config['AGENT'] = None        # Single agent instance
app.config['THREAD'] = None       # Single conversation thread
app.config['CHAT_HISTORY'] = []   # UI display history
app.config['ERROR'] = None        # Error display
```

### Thread Management
- **Agent Framework Threads**: Microsoft Agent Framework manages conversation context
- **OpenAI Responses API**: Server-side thread persistence
- **Flask Session**: Simple UI state management for single-user POC

### Chat History
- **Agent Framework**: Maintains conversation context for LLM
- **Flask App**: Stores display history for UI rendering
- **Persistence**: Thread state preserved across requests

## Graph RAG Configuration

### Environment Variables
```bash
# OpenAI Configuration
OPENAI_API_KEY=your_openai_api_key
OPENAI_RESPONSES_MODEL_ID=gpt-4

# GraphDB Configuration  
GRAPHDB_URL=http://localhost:7200
GRAPHDB_REPOSITORY=jaguar_conservation
```

### Agent Settings
```python
# Hardcoded in create_jaguar_agent()
settings = OpenAISettings(
    api_key=os.getenv("OPENAI_API_KEY", ""),
    model_id=os.getenv("OPENAI_RESPONSES_MODEL_ID", "gpt-4")
)
```

## Graph RAG Response Formatting

The agent applies Graph RAG-specific formatting:
1. **SPARQL Display**: Show generated query in code blocks
2. **Data Attribution**: Always mention jaguar database source
3. **Markdown Formatting**: Use **bold**, bullet points, code blocks
4. **Structured Responses**: Break complex answers into paragraphs

## Error Handling

### Graph RAG Error Levels

1. **SPARQL Errors**: Invalid query syntax, ontology mismatches
2. **GraphDB Errors**: Connection failures, query timeouts
3. **LLM Errors**: OpenAI API failures, rate limits
4. **Web Errors**: Flask request/response errors

### Error Response Format
```python
# Simple error display in Flask
app.config['ERROR'] = str(e)
return redirect(url_for('index'))
```

## Graph RAG Usage Examples

### Running the Application
```bash
# Start the Flask application
cd /home/niklas/workspace/graph_RAG
python3 app.py

# Access the web interface
open http://localhost:5000
```

### Example Queries
Try these Graph RAG queries in the web interface:

**Basic Queries:**
- "How many jaguars are in the database?"
- "Show me all female jaguars"
- "What conservation efforts are being conducted?"

**Complex Queries:**
- "Find jaguars that were killed and their causes of death"
- "Which organizations are conducting conservation efforts?"
- "Show me jaguars by location and their monitoring dates"

### Programmatic Usage
```python
# Direct agent usage (if needed)
from src.agents.jaguar_agent import create_jaguar_agent
import asyncio

agent = create_jaguar_agent()
thread = agent.get_new_thread()

# Run a query
response = asyncio.run(agent.run(
    "How many jaguars are in the database?", 
    thread=thread, 
    store=True
))
print(response.text)
```

## Graph RAG Future Enhancements

### Advanced Graph RAG Features
1. **Multi-Modal Queries**: Combine text and image analysis
2. **Temporal Queries**: Time-based conservation trend analysis
3. **Geospatial Queries**: Location-based jaguar population mapping
4. **Predictive Analytics**: Conservation outcome predictions

### Knowledge Graph Enhancements
1. **Dynamic Ontology Updates**: Real-time ontology evolution
2. **Federated Queries**: Query multiple knowledge graphs
3. **Semantic Reasoning**: Advanced SPARQL reasoning capabilities
4. **Graph Visualization**: Interactive knowledge graph exploration

### Agent Framework Enhancements
1. **Multi-Agent Workflows**: Specialized agents for different tasks
2. **Streaming Responses**: Real-time Graph RAG query processing
3. **Human-in-the-Loop**: Query refinement and validation
4. **Memory Management**: Long-term conversation summarization

## Graph RAG Testing

### Manual Testing
1. **Web Interface**: Test queries through the Flask UI
2. **SPARQL Validation**: Verify generated queries in GraphDB
3. **Response Quality**: Check natural language response accuracy

### Example Test Queries
```python
# Test basic counting
"How many jaguars are in the database?"

# Test filtering
"Show me all male jaguars"

# Test relationships
"Which jaguars were rescued and by which organization?"

# Test complex queries
"Find conservation efforts in Arizona with their success rates"
```

## Graph RAG Performance

### Response Times
- **Simple Queries**: 2-3 seconds (count, basic filters)
- **Complex Queries**: 3-5 seconds (joins, aggregations)
- **No Tool Calls**: 1-2 seconds (general conversation)

### Optimization Strategies
1. **Query Caching**: Cache frequent SPARQL patterns
2. **Index Optimization**: Optimize GraphDB indexes
3. **Response Streaming**: Stream partial results
4. **Async Processing**: Non-blocking GraphDB queries

## Graph RAG Security

### SPARQL Injection Prevention
- **Query Validation**: Validate SPARQL syntax before execution
- **Parameter Escaping**: Properly escape user inputs
- **GraphDB Security**: Leverage GraphDB's built-in security

### Data Privacy
- **Read-Only Access**: Agent only reads from GraphDB
- **No Data Storage**: No user data persisted beyond conversation
- **Secure APIs**: Use HTTPS for all external communications

